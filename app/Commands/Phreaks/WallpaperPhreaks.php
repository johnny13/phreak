<?php

/**
 *
 * Autogenerated with this command
 *
 * php phreak make:a phreak-cmd Wallpaper
 * mv app/Commands/Phreaks/Wallpaper.php app/Commands/Phreaks/WallpaperPhreaks.php
 *
 *
 * No sympathy for the devil; keep that in mind. Buy the ticket, take the ride...
 * and if it occasionally gets a little heavier than what you had in mind, well...
 * maybe chalk it off to forced conscious expansion:
 *      Tune in, freak out, get beaten.
 *
 *
 */

namespace App\Commands\Phreaks;

use App\Commands\Phreaks\TUI;
use App\Commands\Phreaks\ColorPhreaks;
use App\Commands\Phreaks\PalettePhreaks;
use App\Commands\Phreaks\FilePhreaks;

use Dallgoot\Yaml;
use League\CLImate\CLImate;


/**
 * This PHREAK Command [WallpaperPhreaks] provides the backend logic and scripts.
 * Often for a front facing WallpaperCommand, but not always. A phreak can be
 * by itself and not have a sister command.
 */

class WallpaperPhreaks
{

    /**
     *
     *  GLOBAL VARIABLES
     *
     *  NAME              EXAMPLE
     *  --------------|--------------------------------
     *
     *  $climate      =>  self::$climate->out('blah');
     *  $globalWidth  =>  $x = self::$globalWidth;
     *
     */

    public static $climate;
    public static $globalWidth  = 60;
    public static $B16Resources;
    public static $Base16Location = 'resources/palettes/base16/';

    /**
     *
     * CONSTANTS
     *
     */

    const WALLPAPER_LIST = 'tables/wallpapers.json';
    const B16_DIR = "palettes/base16/";


    /**
     * constructStatic
     *
     * Wallpaper static constructor
     *
     * @return void
     */
    public static function __constructStatic()
    {
        setlocale(LC_ALL, 'en_US.UTF8');
        self::$climate = new CLImate;
        self::$B16Resources = resource_path(self::B16_DIR . "*.{yaml,yml,YAML,YML}");
    }

    /**
     * setupColors
     *
     * Gets the colors from a saved palette or a Base16 theme.
     *
     * @param  mixed $type
     * @param  mixed $shuffle
     * @param  mixed $name
     * @return void
     */
    public static function setupColors($type = "base16", $shuffle = true, $name = false)
    {
        $colors   = array();
        $file     = "";
        $bgColor  = "";

        if ($type === "base16") {

            if ($name === false) {
                $themes = glob(self::$B16Resources, GLOB_BRACE);
                shuffle($themes);

                $name = "random";
                $file = $themes[0];
                $themeName = basename($file, ".yaml");
            } else {
                $file = resource_path(self::B16_DIR) . $name . ".yaml";
                $themeName = basename($file, ".yaml");
            }

            TUI::Speaks("  <green>THEME</green> <light_blue>" . $file . "</light_blue>");

            $debug = 0;
            $yaml = Yaml::parseFile($file, 0, $debug);

            $colors[] = $yaml->base08;
            $colors[] = $yaml->base09;
            $colors[] = $yaml->base0A;
            $colors[] = $yaml->base0B;
            $colors[] = $yaml->base0C;
            $colors[] = $yaml->base0D;
            $colors[] = $yaml->base0E;
            $colors[] = $yaml->base0F;

            $bgColor  = $yaml->base00;
        } else if ($type === "palette") {

            // Get the palette data
            $PaletteData = PalettePhreaks::lookupPalette($name);

            // Get the Title
            $themeName = ucfirst($PaletteData->getField("title"));

            // Get Colors from saved palette
            $colors = json_decode($PaletteData->getField("colors"), true);

            // Insanely complex (relatively speaking) method of determining Background color
            // Foreach color, get if light or dark, whichever has most, use that text color
            // TODO: dont use text color from first tested color like is happening.
            // TODO: Ideas instead:
            // TODO: 1. get darkened version of each color for a gradient background
            // TODO: 2. IDK... layer each color on top of each other w/ 50% opacity?
            // TODO: 3. leave it as is but use fixed white / black / gray colors?
            $lightDarkArray = array();
            $ldResults      = array();

            foreach ($colors as $c) {
                $ldData = ColorPhreaks::lightOrDark($c);
                $lightDarkArray[] = $ldData["LightOrDark"];
                $ldResults[$ldData["LightOrDark"]] = $ldData["text"];
            }

            $darkTotal = 0;
            $lightTotal = 0;

            foreach ($lightDarkArray as $ld) {
                if ($ld === "light")
                    $lightTotal++;
                if ($ld === "dark")
                    $darkTotal++;
            }

            if ($lightTotal > $darkTotal)
                $bgColor = $ldResults["light"];
            else
                $bgColor = $ldResults["dark"];

        } else
            TUI::Message("ERROR! Theme Format not understood! Exiting :(", "FAIL");

        // if ($shuffle !== true)
        //     TUI::Message("SHUFFLE NOT BEING PASSED ERROR! FIX!", "FAIL");

        if ($shuffle === true) shuffle($colors);

        $cleanName = FilePhreaks::cleanFilename($themeName, true);

        $bgColor = self::backgroundMinMaxCheck($bgColor);

        $final = array(
            "colors" => $colors,
            "background" => $bgColor,
            "theme" => $themeName,
            "slug" => $cleanName
        );

        return $final;
    }

    public static function backgroundMinMaxCheck($bgColor)
    {
        $bgColor = \strtoupper($bgColor);

        if ($bgColor === "000" || $bgColor === "000000") {
            $amount = rand(13, 23);
            $bgColor = ColorPhreaks::getLighter($bgColor, ($amount * 0.01));
        }

        // TUI::printDEBUG($bgColor);

        return $bgColor;
    }


    /**
     * getTemplates
     *
     * Return an array of all available wallpaper templates.
     *
     * @return array $results by category of all templates
     */
    public static function getTemplates($category = "all", $simple = true)
    {
        $category = ucfirst($category);

        $wpFile   = resource_path(self::WALLPAPER_LIST);
        $wpList   = json_decode(file_get_contents($wpFile), true);

        $results  = self::listAll($wpList["Wallpapers"], $simple);

        if ($category !== "All")
            $results = $results[$category];

        return $results;
    }

    /**
     * listAll
     *
     * return a list of all the wallpaper templates, broken down by category
     *
     * @param  mixed $walls
     * @param  bool $simple what type of results to get back
     * @return array results is a simple array of names, or array of data arrays
     */
    public static function listAll($walls, $simple = true)
    {
        $wallData = array();

        foreach ($walls as $w) {
            foreach ($w as $k => $v) {
                if ($simple === true)
                    $wallData[$k] = array();

                foreach ($v as $items) {
                    if ($simple === true)
                        $wallData[$k][] = $items["name"];
                    else
                        $wallData[] = array("name" => $items["name"], "desc" => $items["desc"], "function" => $items["function"], "params" => $items["params"], "category" => $items["category"]);
                }
            }
        }

        return $wallData;
    }

    public static function printList($walls, $cat = false)
    {
        $rows = array();
        $desc = "TODO: write brief description...";

        foreach ($walls as $name => $wallType) {
            $rows[] = $name;
            $lt = mb_strlen($name);
            $rows[] = TUI::generateLine(($lt + 2));
            foreach ($wallType as $w) {
                $rows[] = $w . " â€¢ " . $desc;
            }
            $rows[] = "";
        }

        $rows[] = "";

        return $rows;
    }

    /**
     * getAttr
     *
     * Get an Attribute
     *
     * @param  string $value
     *
     * @return string
     */
    public function getAttr($value = "")
    {
        $value = ($value !== "" ? "zero" : "one");

        return $value;
    }
}

WallpaperPhreaks::__constructStatic();
